ini codingan authenticationservice : import jwt from 'jsonwebtoken';
import IncorrectCredentialError from '../errors/IncorrectCredentialError';

export default class AuthenticationService {
  #customer;

  constructor(customer) {
    this.#customer = customer;
  }

  async authenticateCustomer(userAccount) {
    const { username, password } = userAccount;
    const existingUser = await this.#customer.findOne({ username, password });
    if (!existingUser) {
      return IncorrectCredentialError();
    }
    const { JWT_SECRET, JWT_EXPIRATION } = process.env;
    const payload = JSON.parse(JSON.stringify(existingUser));
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRATION });
    return { token };
  }
}


incorrect error :
import HttpStatus from 'http-status-codes';

class IncorrectCredentialError extends Error {
  #statusCodes;

  constructor() {
    super('Username and/or password is incorrect');
    this.#statusCodes = HttpStatus.BAD_REQUEST;
  }

  get httpStatus() {
    return this.#statusCodes;
  }
}

export default IncorrectCredentialError;







import jwt from 'jsonwebtoken';
import IncorrectCredentialError from '../../src/errors/IncorrectCredentialError';
import AuthenticationService from '../../src/services/AuthenticationService';

jest.mock('jsonwebtoken');

describe('AuthenticationService', () => {
  const mockCustomer = {
    findOne: jest.fn()
  };
  describe('^authenticateUser', () => {
    it('should search a user with given username and password, sign JWT token and return the token when user exists in database', async () => {
      const foundUser = {
        username: 'test',
        password: '123456'
      };
      const mockToken = 'token';
      mockCustomer.findOne.mockReturnValue(foundUser);
      jwt.sign.mockReturnValue(mockToken);
      const expectedResult = { token: mockToken };
      const authenticationService = new AuthenticationService(mockCustomer);

      const actualResult = await authenticationService.authenticateCustomer(expectedResult);

      expect(actualResult).toEqual(expectedResult);
    });

    it('should not sign JWT token and throw error when given user does not exist in database', async () => {
      const customer = {
        username: 'test',
        password: '123456'
      };
      mockCustomer.findOne.mockResolvedValue(null);
      const expectedError = new IncorrectCredentialError();
      const authenticationService = new AuthenticationService(mockCustomer);
      const actualResult = () => authenticationService.authenticateCustomer(customer);

      await expect(actualResult()).rejects.toThrowError(expectedError);
    });
  });
});

kenapa error dibagian sini await expect(actualResult()).rejects.toThrowError(expectedError); dengan error "Cannot call a class as a function"
