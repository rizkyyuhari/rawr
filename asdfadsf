homepage : 
/* eslint-disable max-len */

import {
  useCallback, useContext, useEffect, useState
} from 'react';
import { CircularProgress } from '@mui/material';
import axios from 'axios';
import ErrorComponent from '@src/components/ErrorComponent';
import { CustomerContext } from '@src/components/CustomerProvider';
import ProfitAndLossView from './ProfitAndLossView';
import HomePageProfile from './HomePageProfile';

const BASE_URL = 'http://localhost:8000';

const todaysDate = new Date();
const params = {
  dateTo: todaysDate,
  dateFrom: new Date(todaysDate.getFullYear(), todaysDate.getMonth(), todaysDate.getDate() - 6)
};

const HomePage = () => {
  const { customerData } = useContext(CustomerContext);
  const [data, setData] = useState({
    finalData: [],
    customer: customerData,
    balance: 0
  });
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);

  const getCustomerBalance = (item) => {
    const IDR = 'IDR';
    const rupiahTicker = item?.tickers.find((ticker) => ticker.ticker === IDR);
    return rupiahTicker?.amount;
  };

  const getTodayPortfolio = (portfolios) => portfolios?.find(
    (portfolio) => new Date(portfolio.date).toLocaleDateString() === new Date().toLocaleDateString()
  );

  const getGraphBalance = (portfolio, priceHistories, portfolioDate) => portfolio.tickers
    .map((ticker) => {
      const price = priceHistories.find((priceHistory) => {
        const priceDate = new Date(priceHistory.date).toLocaleDateString();
        return portfolioDate === priceDate && priceHistory.ticker.ticker === ticker.ticker;
      });
      return price?.price ? ticker.amount * price.price : ticker.amount;
    })
    .reduce((total, tickerPrice) => total + tickerPrice, 0);

  const getTransactions = (transactions, portfolioDate) => transactions.filter((transaction) => {
    const transactionDate = new Date(transaction.date).toLocaleDateString();
    return transactionDate === portfolioDate;
  });

  const getFinalData = useCallback((databaseData) => {
    const { priceHistories, portfolios, transactions } = databaseData;
    return portfolios.map((portfolio) => {
      const portfolioDate = new Date(portfolio.date).toLocaleDateString();
      return {
        balance: getGraphBalance(portfolio, priceHistories, portfolioDate),
        date: portfolio.date,
        transactions: getTransactions(transactions, portfolioDate)
      };
    });
  }, []);

  const fetchData = useCallback(async () => {
    const token = localStorage.getItem('login');
    const headers = {
      Authorization: `Bearer ${token}`
    };
    try {
      setIsLoading(true);
      setIsError(false);
      const {
        data: { priceHistories }
      } = await axios.get(`${BASE_URL}/price-histories`, { params, headers });
      const {
        data: { transactions }
      } = await axios.get(`${BASE_URL}/customers/${customerData.id}/transactions`, { headers });
      const {
        data: { portfolios }
      } = await axios.get(`${BASE_URL}/customers/${customerData.id}/portfolio-histories`, {
        params,
        headers
      });

      const apiData = {
        portfolios,
        priceHistories,
        transactions
      };
      const customerBalance = getCustomerBalance(getTodayPortfolio(apiData.portfolios));
      const finalData = getFinalData(apiData);
      setData({
        ...data,
        finalData,
        balance: customerBalance
      });
    } catch (error) {
      setIsError(true);
    } finally {
      setIsLoading(false);
    }
  }, [getFinalData]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  if (isLoading) {
    return (
      <div className="flex flex-1 flex-col items-center justify-center rounded-xl p-10 shadow-cw">
        <CircularProgress data-testid="portfolio-loader" />
      </div>
    );
  }

  if (isError) {
    return <ErrorComponent />;
  }

  return (
    <div className="container overflow-auto">
      <p className="text-2xl font-bold">Home Page</p>
      <HomePageProfile data={data.customer} balance={data.balance} />
      <ProfitAndLossView data={data.finalData} />
    </div>
  );
};

export default HomePage;
nah saya testing begini import userEvent from '@testing-library/user-event';
import { render } from '@testing-library/react';
import { createMemoryRouter, RouterProvider, MemoryRouter } from 'react-router-dom';
import axios from 'axios';
import appRoutes from '@src/appRoutes';
import LoginPage from '@src/pages/LoginPage/LoginPage';
import { CustomerProvider } from '@src/components/CustomerProvider';
import mockLocalStorage from '../../mockLocalStorage';
import profitAndLossData from '../../fixtures/profitAndLossData';
import { decodedCustomer, token } from '../../fixtures/customer';

jest.mock('axios', () => ({
  post: jest.fn(),
  get: jest.fn()
}));

Object.defineProperty(window, 'localStorage', { value: mockLocalStorage });

beforeEach(() => {
  jest.resetAllMocks();
});
describe('LoginPage', () => {
  const createRouter = () =>
    createMemoryRouter(appRoutes, {
      initialEntries: ['/login'],
      initialIndex: 0
    });

  it('should display login form with username input password input and button sign in', async () => {
    const router = createRouter();
    const { getByText, getByLabelText, getAllByRole } = render(<RouterProvider router={router} />);

    expect(getByText('Log in')).toBeDefined();
    expect(getByText('Welcome Back!')).toBeDefined();
    expect(getByText('Please enter your details')).toBeDefined();
    expect(getByLabelText('Password')).toBeDefined();
    expect(getByLabelText('Username')).toBeDefined();
    expect(getAllByRole('img')).toBeDefined();
  });
  it('should navigate to dashboard with route / when customer succesfully login', async () => {
    const router = createRouter();
    const response = { data: { token } };
    const { portfolios, priceHistories, transactions } = profitAndLossData;
    const customer = userEvent.setup();
    const setCustomerDataMock = jest.fn();
    axios.post.mockResolvedValue(response);
    axios.get
      .mockResolvedValueOnce({ data: { priceHistories } })
      .mockResolvedValueOnce({ data: { transactions } })
      .mockResolvedValueOnce({ data: { portfolios } });

    const { findByText, getByLabelText, getByRole } = render(
      <CustomerProvider value={{ decodedCustomer, setCustomerDataMock }}>
        <RouterProvider router={router} />
      </CustomerProvider>
    );
    const usernameInput = getByLabelText('Username');
    const passwordInput = getByLabelText('Password');
    const loginButton = getByRole('button', { name: 'Log in' });
    const username = 'rizky';
    const password = 'test123';
    await userEvent.type(usernameInput, username);
    await userEvent.type(passwordInput, password);
    await customer.click(loginButton);

    expect(await findByText('Home Page')).toBeDefined();
  });

});
kenapa error Failed to create chart: can't acquire context from the given item
