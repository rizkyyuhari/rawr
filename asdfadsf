ini react native context
import PropTypes from 'prop-types';
import React, { createContext, useEffect, useMemo, useState } from 'react';
import EncryptedStorage from 'react-native-encrypted-storage';
import { Buffer } from 'buffer';

const initialData = {
  id: '',
  username: '',
  name: ''
};

const CustomerContext = createContext(initialData);

const CustomerProvider = ({ children }) => {
  const [customerData, setCustomerData] = useState(initialData);
  const context = useMemo(
    () => ({
      customerData,
      setCustomerData
    }),
    [customerData]
  );

  console.log(customerData);

  const checkingToken = async () => {
    const token = await EncryptedStorage.getItem('login');
    if (token) {
      const parts = token
        .split('.')
        .map((part) =>
          Buffer.from(
            part.replace(/-/g, '+').replace(/_/g, '/'),
            'base64'
          ).toString()
        );
      const decodedCustomer = JSON.parse(parts[1]);
      console.log('decodedCustomer', decodedCustomer);
      setCustomerData(decodedCustomer);
    }
  };

  useEffect(() => {
    checkingToken();
  }, []);

  return (
    <CustomerContext.Provider value={context}>
      {children}
    </CustomerContext.Provider>
  );
};

CustomerProvider.propTypes = {
  children: PropTypes.node.isRequired
};

export { CustomerContext, CustomerProvider };

ini authenticated navigator import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import FontAwesome6 from 'react-native-vector-icons/FontAwesome6';
import TransactionHistoryScreen from '../screens/TransactionHistoryScreen/TransactionHistoryScreen';
import FontAwesome from 'react-native-vector-icons/FontAwesome';
import CWText from '../components/CWText';
import DashboardScreen from '../screens/DashboardScreen/DashboardScreen';
import MarketNavigator from './MarketNavigator';
import PortfolioScreen from '../screens/PortfolioScreen/PortfolioScreen';

const Tab = createBottomTabNavigator();

const AuthenticatedNavigator = () => {
  const iconColor = {
    true: '#0300A2',
    false: '#8D8DA6'
  };

  const labelColor = {
    true: 'text-xs text-cw-blue',
    false: 'text-xs text-cw-grey'
  };

  const renderDashboardLabel = (focused) => (
    <CWText
      className={labelColor[focused]}
      fontWeight={500}
      color={iconColor[focused]}>
      Dashboard
    </CWText>
  );

  const renderDashboardIcon = (focused) => (
    <FontAwesome6 name="house" size={20} color={iconColor[focused]} />
  );

  const renderMarketLabel = (focused) => {
    return (
      <CWText
        className={labelColor[focused]}
        fontWeight={500}
        color={iconColor[focused]}>
        Market
      </CWText>
    );
  };

  const renderMarketIcon = (focused) => {
    return <FontAwesome6 name="shop" size={20} color={iconColor[focused]} />;
  };

  const renderTransactionHistoryLabel = (focused) => {
    return (
      <CWText
        className={labelColor[focused]}
        fontWeight={500}
        color={iconColor[focused]}>
        History
      </CWText>
    );
  };

  const renderTransactionHistoryIcon = (focused) => {
    return <FontAwesome name="history" size={20} color={iconColor[focused]} />;
  };

  const renderPortfolioLabel = (focused) => {
    return (
      <CWText
        className={labelColor[focused]}
        fontWeight={500}
        color={iconColor[focused]}>
        Portfolio
      </CWText>
    );
  };

  const renderPortfolioIcon = (focused) => {
    return (
      <FontAwesome6 name="chart-simple" size={20} color={iconColor[focused]} />
    );
  };

  const tabScreensOptions = {
    dashboardScreen: {
      tabBarLabel: ({ focused }) => renderDashboardLabel(focused),
      tabBarIcon: ({ focused }) => renderDashboardIcon(focused)
    },
    portfolioScreen: {
      tabBarLabel: ({ focused }) => renderPortfolioLabel(focused),
      tabBarIcon: ({ focused }) => renderPortfolioIcon(focused)
    },
    transactionHistoryScreen: {
      tabBarLabel: ({ focused }) => renderTransactionHistoryLabel(focused),
      tabBarIcon: ({ focused }) => renderTransactionHistoryIcon(focused)
    },
    marketScreen: {
      tabBarLabel: ({ focused }) => renderMarketLabel(focused),
      tabBarIcon: ({ focused }) => renderMarketIcon(focused)
    }
  };

  return (
    <Tab.Navigator
      screenOptions={{
        headerShown: false
      }}>
      <Tab.Screen
        name="DashboardScreen"
        component={DashboardScreen}
        options={tabScreensOptions.dashboardScreen}
      />
      <Tab.Screen
        name="MarketNavigator"
        component={MarketNavigator}
        options={tabScreensOptions.marketScreen}
      />
      <Tab.Screen
        name="History"
        component={TransactionHistoryScreen}
        options={tabScreensOptions.transactionHistoryScreen}
      />
      <Tab.Screen
        name="PortfolioScreen"
        component={PortfolioScreen}
        options={tabScreensOptions.portfolioScreen}
      />
    </Tab.Navigator>
  );
};

export default AuthenticatedNavigator;

ini main navigator import { createNativeStackNavigator } from '@react-navigation/native-stack';
import React from 'react';
import LoginScreen from '../screens/LoginScreen/LoginScreen';
import SplashScreen from '../screens/SplashScreen/SplashScreen';
import AuthenticatedNavigator from './AuthenticatedNavigator';

const Stack = createNativeStackNavigator();

const MainNavigator = () => {
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      <Stack.Screen name="Splash" component={SplashScreen} />
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen
        name="Authenticated"
        component={AuthenticatedNavigator}
        options={{ headerShown: false }}
      />
    </Stack.Navigator>
  );
};

export default MainNavigator;
ini app jsx
import { NavigationContainer } from '@react-navigation/native';
import React from 'react';
import { SafeAreaView } from 'react-native';
import { CustomerProvider } from './components/CustomerProvider';
import MainNavigator from './navigator/MainNavigator';

const App = () => {
  return (
    <SafeAreaView className="flex-1">
      <CustomerProvider>
        <NavigationContainer>
          <MainNavigator />
        </NavigationContainer>
      </CustomerProvider>
    </SafeAreaView>
  );
};

export default App;

ini dashboard:
import React, { useCallback, useContext, useState } from 'react';
import { ActivityIndicator, Pressable, ScrollView, View } from 'react-native';
import CWText from '../../components/CWText';
import DashboardLineChart from './DashboardLineChart';
import DashboardProfile from './DashboardProfile';
import EncryptedStorage from 'react-native-encrypted-storage';
import PropTypes from 'prop-types';

import DashboardProfitDetailScreen from './DashboardProfitDetailScreen';
import {
  priceHistoriesURL,
  transactionsURL,
  portfoliosURL
} from '../../config/config';
import axios from 'axios';
import { useFocusEffect } from '@react-navigation/native';
import { CustomerContext } from '../../components/CustomerProvider';

const DashboardScreen = ({ navigation }) => {
  const { customerData } = useContext(CustomerContext);
  const [pointDetail, setPointDetail] = useState();
  const [chartData, setChartData] = useState({
    graphData: [],
    baseData: [],
    customer: customerData,
    balance: 0
  });
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const getEndDate = () => {
    return new Date();
  };

  const getStartDate = () => {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 6);
    return startDate;
  };

  const getCustomerBalance = (data) => {
    const IDR = 'IDR';
    const rupiahTicker = data.tickers.find((ticker) => ticker.ticker === IDR);
    return rupiahTicker?.amount;
  };

  const getTodayPortfolio = (portfolios) => {
    return portfolios.find((portfolio) => {
      return (
        new Date(portfolio.date).toLocaleDateString() ===
        new Date().toLocaleDateString()
      );
    });
  };

  const fetchData = useCallback(async () => {
    const token = await EncryptedStorage.getItem('token');
    const headers = {
      Authorization: `Bearer ${token}`
    };

    try {
      setIsLoading(true);
      setIsError(false);
      const startDate = getStartDate();
      const endDate = getEndDate();

      const { data: portfolios } = await axios.get(
        `${portfoliosURL}?dateFrom=${startDate.toLocaleDateString()}&dateTo=${endDate.toLocaleDateString()}`,
        { headers }
      );
      const { data: priceHistories } = await axios.get(
        `${priceHistoriesURL}?dateFrom=${startDate.toLocaleDateString()}&dateTo=${endDate.toLocaleDateString()}`,
        { headers }
      );
      const { data: transactions } = await axios.get(transactionsURL, {
        headers
      });

      const apiData = {
        portfolios: portfolios.portfolios,
        priceHistories: priceHistories.priceHistories,
        transactions: transactions.transactions
      };
      const graphData = getGraphData(apiData);
      const baseData = getBaseData(graphData);
      const customerBalance = getCustomerBalance(
        getTodayPortfolio(apiData.portfolios)
      );
      setChartData((data) => ({
        ...data,
        graphData: graphData,
        baseData: baseData,
        customer: customerData,
        balance: customerBalance
      }));
    } catch (error) {
      setErrorMessage('Oops, something wrong!');
      setIsError(true);
    } finally {
      setIsLoading(false);
    }
  }, [getBaseData, getGraphData, customerData]);

  useFocusEffect(
    useCallback(() => {
      fetchData();
    }, [fetchData])
  );

  const getGraphBalance = (portfolio, priceHistories, portfolioDate) => {
    return portfolio.tickers
      .map((ticker) => {
        const price = priceHistories.find((priceHistory) => {
          const priceDate = new Date(priceHistory.date).toLocaleDateString();
          return (
            portfolioDate === priceDate &&
            priceHistory.ticker.ticker === ticker.ticker
          );
        });
        return price?.price ? ticker.amount * price?.price : ticker.amount;
      })
      .reduce((total, tickerPrice) => total + tickerPrice, 0);
  };

  const getDate = (portfolio) => {
    return new Date(portfolio.date).toLocaleDateString('id-ID', {
      day: '2-digit',
      month: 'short',
      year: 'numeric'
    });
  };

  const getTransactions = (transactions, portfolioDate) => {
    return transactions.filter((transaction) => {
      const transactionDate = new Date(transaction.date).toLocaleDateString();
      return transactionDate === portfolioDate;
    });
  };

  const getGraphData = useCallback((data) => {
    const { priceHistories, portfolios, transactions } = data;
    return portfolios.map((portfolio) => {
      const portfolioDate = new Date(portfolio.date).toLocaleDateString();
      return {
        balance: getGraphBalance(portfolio, priceHistories, portfolioDate),
        date: getDate(portfolio),
        transactions: getTransactions(transactions, portfolioDate)
      };
    });
  }, []);

  const getBaseData = useCallback((data) => {
    const newBaseData = [];

    data.map((item, index) => {
      newBaseData.push({
        ...item,
        balance: data[0].balance,
        date: data[index].date
      });
    });

    return newBaseData;
  }, []);

  const handleProfitDetailClick = (dataPoint) => {
    dataPoint.map((point) => {
      setPointDetail({
        ...pointDetail,
        balance: point.balance,
        date: point.date,
        transactions: point.transactions,
        x: point._x,
        y: point._y
      });
    });
  };

  if (isLoading) {
    return (
      <View className="flex-1 justify-center items-center bg-cw-lightpurple">
        <ActivityIndicator
          accessibilityLabel="loader-activity"
          size="large"
          color="blue"
        />
      </View>
    );
  }

  if (errorMessage && isError) {
    return (
      <View className="flex-1 justify-center items-center bg-cw-lightpurple">
        <CWText className="text-2xl text-center">{errorMessage}</CWText>
      </View>
    );
  }

  const handleLogout = async () => {
    await EncryptedStorage.removeItem('token');
    navigation.replace('Login');
  };

  return (
    <ScrollView className="flex-1 min-w-full bg-cw-lightgrey">
      <View className="flex-1 h-full" accessibilityLabel="Dashboard">
        {chartData.graphData.length > 0 && (
          <View>
            <View className="px-6 justify-center flex-col">
              <DashboardProfile
                customerData={chartData.customer}
                balance={chartData.balance}
              />
            </View>
            <View accessibilityLabel="profit loss line chart">
              <DashboardLineChart
                data={chartData.graphData}
                baseData={chartData.baseData}
                handleProfitDetailClick={handleProfitDetailClick}
              />
            </View>
            {pointDetail ? (
              <DashboardProfitDetailScreen pointDetail={pointDetail} />
            ) : null}
          </View>
        )}
        <Pressable
          accessibilityLabel="logout-button"
          className="items-center"
          onPress={handleLogout}>
          <CWText className=" p-2 text-white bg-cw-purple">Logout</CWText>
        </Pressable>
      </View>
    </ScrollView>
  );
};

DashboardScreen.propTypes = {
  navigation: PropTypes.shape({
    replace: PropTypes.func
  })
};

export default DashboardScreen;



/* eslint-disable testing-library/no-node-access */
import React from 'react';
import { render, screen, act } from '@testing-library/react-native';
import DashboardScreen from '../../../src/screens/DashboardScreen/DashboardScreen';
import axios from 'axios';
import { when } from 'jest-when';
import { portfoliosResponse } from '../../fixturesFolder/portfolio';
import { transactionsResponse } from '../../fixturesFolder/transactions';
import priceHistoriesResponse from '../../fixturesFolder/priceHistory';
import {
  customerURL,
  portfoliosURL,
  priceHistoriesURL,
  transactionsURL
} from '../../../src/config/config';
import { VictoryVoronoiContainer } from 'victory-native';
import { View } from 'react-native';
import { pointDetail } from '../../fixturesFolder/pointDetail';
import convertToRupiah from '../../../src/utils/convertToRupiah';
import {
  customerData,
  decodedCustomer,
  token
} from '../../fixturesFolder/customerData';
import EncryptedStorage from 'react-native-encrypted-storage';
import { useFocusEffect } from '@react-navigation/native';
import { CustomerProvider } from '../../../src/components/CustomerProvider';

jest.mock('@react-navigation/native', () => ({
  useFocusEffect: jest.fn(),
  navigation: jest.fn()
}));

jest.mock('axios', () => ({
  get: jest.fn()
}));

jest.mock('@react-navigation/native', () => ({
  useFocusEffect: jest.fn()
}));

jest.mock('react-native-encrypted-storage', () => ({
  getItem: jest.fn()
}));

jest.mock('victory-native', () => {
  const originalModule = jest.requireActual('victory-native');

  return {
    ...originalModule,
    VictoryVoronoiContainer: jest.fn()
  };
});

describe('DashboardScreen', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.resetAllMocks();
  });

  it('should display text dashboard in dashboard route when app is running', async () => {
    EncryptedStorage.getItem.mockResolvedValue(token);
    const headers = {
      Authorization: `Bearer ${token}`
    };
    VictoryVoronoiContainer.mockImplementation(() => (
      <View accessibilityLabel="container" />
    ));
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 6);
    useFocusEffect.mockImplementationOnce((callback) => callback());
    when(axios.get)
      .calledWith(
        `${portfoliosURL}?dateFrom=${startDate.toLocaleDateString()}&dateTo=${endDate.toLocaleDateString()}`,
        { headers }
      )
      .mockResolvedValue({ data: portfoliosResponse })
      .calledWith(
        `${priceHistoriesURL}?dateFrom=${startDate.toLocaleDateString()}&dateTo=${endDate.toLocaleDateString()}`,
        { headers }
      )
      .mockResolvedValue({ data: priceHistoriesResponse })
      .calledWith(transactionsURL, { headers })
      .mockResolvedValue({ data: transactionsResponse });
    const setCustomerMock = jest.fn();
    render(
      <CustomerProvider value={{ decodedCustomer, setCustomerMock }}>
        <DashboardScreen />
      </CustomerProvider>
    );

    expect(await screen.findByLabelText('loader-activity')).toBeDefined();

    const dashboardHeading = await screen.findByLabelText('Dashboard');

    expect(dashboardHeading).toBeDefined();
    expect(axios.get).toHaveBeenCalledTimes(3);

    const profileContainer = await screen.findByLabelText('Account balance');
    const username = screen.getByText(`Welcome, ${decodedCustomer.name}`);

    expect(profileContainer).toBeDefined();
    expect(username).toBeDefined();

    const profitGraphContainer = screen.getByLabelText(
      'profit loss line chart'
    );

    expect(profitGraphContainer).toBeDefined();

    const mockVictoryContainer = VictoryVoronoiContainer.mock.calls[0][0];
    const activatedMethod = mockVictoryContainer.onActivated;
    const labelsMethod = mockVictoryContainer.labels;
    const datum = {
      balance: 58554004.9,
      date: '07 Nov 2023',
      transactions: []
    };
    const balanceTickFormatResult =
      mockVictoryContainer.children[0].props.tickFormat(1000000);
    const dateTickFormatResult =
      mockVictoryContainer.children[1].props.tickFormat(datum.date);

    await act(async () => {
      activatedMethod([pointDetail]);
    });
    labelsMethod({
      datum
    });

    expect(balanceTickFormatResult).toEqual('1M');
    expect(dateTickFormatResult).toEqual('07 Nov');
    expect(convertToRupiah(datum.balance)).toBeDefined();
    expect(datum.date).toBeDefined();
  });
});



